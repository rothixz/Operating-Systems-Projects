<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>SOFS15: sofs_ifuncs_4.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SOFS15
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">FUSE based file system</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('sofs__ifuncs__4_8h.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#define-members">Macros</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sofs_ifuncs_4.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Set of operations to manage directories and directory entries: level 4 of the internal file system organization.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &quot;<a class="el" href="sofs__direntry_8h_source.html">sofs_direntry.h</a>&quot;</code><br/>
</div>
<p><a href="sofs__ifuncs__4_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a97fe5470fb1ac167c713671655ff3e52"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a97fe5470fb1ac167c713671655ff3e52"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__4_8h.html#a97fe5470fb1ac167c713671655ff3e52">ADD</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a97fe5470fb1ac167c713671655ff3e52"><td class="mdescLeft">&#160;</td><td class="mdescRight">operation add a generic entry to a directory <br/></td></tr>
<tr class="separator:a97fe5470fb1ac167c713671655ff3e52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeb431dcae0a76d2f175a1f413ae36e84"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aeb431dcae0a76d2f175a1f413ae36e84"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__4_8h.html#aeb431dcae0a76d2f175a1f413ae36e84">ATTACH</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:aeb431dcae0a76d2f175a1f413ae36e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">operation attach an entry to a directory to a directory <br/></td></tr>
<tr class="separator:aeb431dcae0a76d2f175a1f413ae36e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a4c0be4e2e15f7167f711d5769b01a049"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a4c0be4e2e15f7167f711d5769b01a049"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__4_8h.html#a4c0be4e2e15f7167f711d5769b01a049">REM</a>&#160;&#160;&#160;0</td></tr>
<tr class="memdesc:a4c0be4e2e15f7167f711d5769b01a049"><td class="mdescLeft">&#160;</td><td class="mdescRight">operation remove a generic entry from a directory <br/></td></tr>
<tr class="separator:a4c0be4e2e15f7167f711d5769b01a049"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8d08c8624a47f26429c55440f93f0d9d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a8d08c8624a47f26429c55440f93f0d9d"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__4_8h.html#a8d08c8624a47f26429c55440f93f0d9d">DETACH</a>&#160;&#160;&#160;1</td></tr>
<tr class="memdesc:a8d08c8624a47f26429c55440f93f0d9d"><td class="mdescLeft">&#160;</td><td class="mdescRight">operation detach a generic entry from a directory <br/></td></tr>
<tr class="separator:a8d08c8624a47f26429c55440f93f0d9d"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a2024d0c565f39654f043be4601e65a6c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__4_8h.html#a2024d0c565f39654f043be4601e65a6c">soGetDirEntryByPath</a> (const char *ePath, uint32_t *p_nInodeDir, uint32_t *p_nInodeEnt)</td></tr>
<tr class="memdesc:a2024d0c565f39654f043be4601e65a6c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an entry by path.  <a href="#a2024d0c565f39654f043be4601e65a6c">More...</a><br/></td></tr>
<tr class="separator:a2024d0c565f39654f043be4601e65a6c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3eca70b0687bbba94edbab2520a66eaa"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__4_8h.html#a3eca70b0687bbba94edbab2520a66eaa">soGetDirEntryByName</a> (uint32_t nInodeDir, const char *eName, uint32_t *p_nInodeEnt, uint32_t *p_idx)</td></tr>
<tr class="memdesc:a3eca70b0687bbba94edbab2520a66eaa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get an entry by name.  <a href="#a3eca70b0687bbba94edbab2520a66eaa">More...</a><br/></td></tr>
<tr class="separator:a3eca70b0687bbba94edbab2520a66eaa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a832e5a96d37f263c3615eeed64464fac"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__4_8h.html#a832e5a96d37f263c3615eeed64464fac">soAddAttDirEntry</a> (uint32_t nInodeDir, const char *eName, uint32_t nInodeEnt, uint32_t op)</td></tr>
<tr class="memdesc:a832e5a96d37f263c3615eeed64464fac"><td class="mdescLeft">&#160;</td><td class="mdescRight">Add a generic entry / attach an entry to a directory to a directory.  <a href="#a832e5a96d37f263c3615eeed64464fac">More...</a><br/></td></tr>
<tr class="separator:a832e5a96d37f263c3615eeed64464fac"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46ca5d058bd03b02a459e4ce3f9769de"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__4_8h.html#a46ca5d058bd03b02a459e4ce3f9769de">soRemDetachDirEntry</a> (uint32_t nInodeDir, const char *eName, uint32_t op)</td></tr>
<tr class="memdesc:a46ca5d058bd03b02a459e4ce3f9769de"><td class="mdescLeft">&#160;</td><td class="mdescRight">Remove / detach a generic entry from a directory.  <a href="#a46ca5d058bd03b02a459e4ce3f9769de">More...</a><br/></td></tr>
<tr class="separator:a46ca5d058bd03b02a459e4ce3f9769de"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab2b1d32979a19de7d7858adc48963c39"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__4_8h.html#ab2b1d32979a19de7d7858adc48963c39">soRenameDirEntry</a> (uint32_t nInodeDir, const char *oldName, const char *newName)</td></tr>
<tr class="memdesc:ab2b1d32979a19de7d7858adc48963c39"><td class="mdescLeft">&#160;</td><td class="mdescRight">Rename an entry of a directory.  <a href="#ab2b1d32979a19de7d7858adc48963c39">More...</a><br/></td></tr>
<tr class="separator:ab2b1d32979a19de7d7858adc48963c39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a683c0a38a52d73d362edb1f9aba5778c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__ifuncs__4_8h.html#a683c0a38a52d73d362edb1f9aba5778c">soCheckDirectoryEmptiness</a> (uint32_t nInodeDir)</td></tr>
<tr class="memdesc:a683c0a38a52d73d362edb1f9aba5778c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check a directory status of emptiness.  <a href="#a683c0a38a52d73d362edb1f9aba5778c">More...</a><br/></td></tr>
<tr class="separator:a683c0a38a52d73d362edb1f9aba5778c"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Set of operations to manage directories and directory entries: level 4 of the internal file system organization. </p>
<p>(interface file) </p>
<pre class="fragment">  The aim is to provide an unique description of the functions that operate at this level.
</pre><p>The operations are: </p>
<ul>
<li>get an entry by path </li>
<li>get an entry by name </li>
<li>add a generic entry / attach an entry to a directory to a directory </li>
<li>remove / detach a generic entry from a directory </li>
<li>rename an entry of a directory </li>
<li>check a directory status of emptiness.</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Artur Carneiro Pereira September 2008 </dd>
<dd>
Miguel Oliveira e Silva September 2009 </dd>
<dd>
António Rui Borges - October 2012</dd></dl>
<dl class="section remark"><dt>Remarks</dt><dd>In case an error occurs, all functions return a negative value which is the symmetric of the system error or the local error that better represents the error cause. Local errors are out of the range of the system errors. </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="a832e5a96d37f263c3615eeed64464fac"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soAddAttDirEntry </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nInodeDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nInodeEnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Add a generic entry / attach an entry to a directory to a directory. </p>
<p>In the first case, a generic entry whose name is <code>eName</code> and whose inode number is <code>nInodeEnt</code> is added to the directory associated with the inode whose number is <code>nInodeDir</code>. Thus, both inodes must be in use and belong to a legal type, the former, and to the directory type, the latter.</p>
<p>Whenever the type of the inode associated to the entry to be added is of directory type, the directory is initialized by setting its contents to represent an empty directory.</p>
<p>In the second case, an entry to a directory whose name is <code>eName</code> and whose inode number is <code>nInodeEnt</code> is attached to the directory, the so called <em>base directory</em>, associated to the inode whose number is <code>nInodeDir</code>. The entry to be attached is supposed to represent itself a fully organized directory, the so called <em>subsidiary directory</em>. Thus, both inodes must be in use and belong to the directory type.</p>
<p>The <code>eName</code> must be a <em>base name</em> and not a <em>path</em>, that is, it can not contain the character '/'. Besides there should not already be any entry in the directory whose <em>name</em> field is <code>eName</code>.</p>
<p>The <em>refcount</em> field of the inode associated to the entry to be added / updated and, when required, of the inode associated to the directory are updated. This may also happen to the <em>size</em> field of either or both inodes.</p>
<p>The process that calls the operation must have write (w) and execution (x) permissions on the directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInodeDir</td><td>number of the inode associated to the directory </td></tr>
    <tr><td class="paramname">eName</td><td>pointer to the string holding the name of the entry to be added / attached </td></tr>
    <tr><td class="paramname">nInodeEnt</td><td>number of the inode associated to the entry to be added / attached </td></tr>
    <tr><td class="paramname">op</td><td>type of operation (ADD / ATTACH)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if any of the <em>inode numbers</em> are out of range or the pointer to the string is <code>NULL</code> or the name string does not describe a file name or no operation of the defined class is described </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the name string exceeds the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if the inode type whose number is <code>nInodeDir</code> (ADD), or both the inode types (ATTACH), are not directories </dd>
<dd>
-<code>EEXIST</code>, if an entry with the <code>eName</code> already exists </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on the directory where the entry is to be added / attached </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the directory where the entry is to be added / attached </dd>
<dd>
-<code>EMLINK</code>, if the maximum number of hardlinks in either one of inodes has already been attained </dd>
<dd>
-<code>EFBIG</code>, if the directory where the entry is to be added / attached, has already grown to its maximum size </dd>
<dd>
-<code>ENOSPC</code>, if there are no free data clusters </dd>
<dd>
-<code>EDIRINVAL</code>, if the directory is inconsistent </dd>
<dd>
-<code>EDEINVAL</code>, if the directory entry is inconsistent </dd>
<dd>
-<code>EIUININVAL</code>, if the inode in use is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>EDCINVAL</code>, if the data cluster header is inconsistent </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a683c0a38a52d73d362edb1f9aba5778c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soCheckDirectoryEmptiness </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nInodeDir</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check a directory status of emptiness. </p>
<p>The directory contents is parsed to assert if all its entries, except for the first two, are free. Thus, the inode associated to the directory must be in use and belong to the directory type.</p>
<p>The two first aforementioned entries must be in use and be named, respectively, "." and "..".</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInodeDir</td><td>number of the inode associated to the directory</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, if the directory is empty </dd>
<dd>
-<code>ENOTEMPTY</code>, if the directory is not empty </dd>
<dd>
-<code>EINVAL</code>, if the <em>inode number</em> is out of range </dd>
<dd>
-<code>ENOTDIR</code>, if the inode type is not a directory </dd>
<dd>
-<code>ENOTEMPTY</code>, if the directory is not empty </dd>
<dd>
-<code>EDIRINVAL</code>, if the directory is inconsistent </dd>
<dd>
-<code>EDEINVAL</code>, if the directory entry is inconsistent </dd>
<dd>
-<code>EIUININVAL</code>, if the inode in use is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a3eca70b0687bbba94edbab2520a66eaa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soGetDirEntryByName </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nInodeDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_nInodeEnt</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_idx</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an entry by name. </p>
<p>The directory contents, seen as an array of directory entries, is parsed to find an entry whose name is <code>eName</code>. Thus, the inode associated to the directory must be in use and belong to the directory type.</p>
<p>The <code>eName</code> must also be a <em>base name</em> and not a <em>path</em>, that is, it can not contain the character '/'.</p>
<p>The process that calls the operation must have execution (x) permission on the directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInodeDir</td><td>number of the inode associated to the directory </td></tr>
    <tr><td class="paramname">eName</td><td>pointer to the string holding the name of the directory entry to be located </td></tr>
    <tr><td class="paramname">p_nInodeEnt</td><td>pointer to the location where the number of the inode associated to the directory entry whose name is passed, is to be stored (nothing is stored if <code>NULL</code>) </td></tr>
    <tr><td class="paramname">p_idx</td><td>pointer to the location where the index to the directory entry whose name is passed, or the index of the first entry that is free, is to be stored (nothing is stored if <code>NULL</code>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the <em>inode number</em> is out of range or the pointer to the string is <code>NULL</code> or the name string does not describe a file name </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the name string exceeds the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if the inode type is not a directory </dd>
<dd>
-<code>ENOENT</code>, if no entry with <code>name</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on the directory </dd>
<dd>
-<code>EDIRINVAL</code>, if the directory is inconsistent </dd>
<dd>
-<code>EDEINVAL</code>, if the directory entry is inconsistent </dd>
<dd>
-<code>EIUININVAL</code>, if the inode in use is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a2024d0c565f39654f043be4601e65a6c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soGetDirEntryByPath </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_nInodeDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t *&#160;</td>
          <td class="paramname"><em>p_nInodeEnt</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get an entry by path. </p>
<p>The directory hierarchy of the file system is traversed to find an entry whose name is the rightmost component of <code>ePath</code>. The path is supposed to be absolute and each component of <code>ePath</code>, with the exception of the rightmost one, should be a directory name or symbolic link name to a path.</p>
<p>The process that calls the operation must have execution (x) permission on all the components of the path with exception of the rightmost one.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ePath</td><td>pointer to the string holding the name of the path </td></tr>
    <tr><td class="paramname">p_nInodeDir</td><td>pointer to the location where the number of the inode associated to the directory that holds the entry is to be stored (nothing is stored if <code>NULL</code>) </td></tr>
    <tr><td class="paramname">p_nInodeEnt</td><td>pointer to the location where the number of the inode associated to the entry is to be stored (nothing is stored if <code>NULL</code>)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path or any of the path components exceed the maximum allowed length </dd>
<dd>
-<code>ERELPATH</code>, if the path is relative and it is not a symbolic link </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EDIRINVAL</code>, if the directory is inconsistent </dd>
<dd>
-<code>EDEINVAL</code>, if the directory entry is inconsistent </dd>
<dd>
-<code>EIUININVAL</code>, if the inode in use is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a46ca5d058bd03b02a459e4ce3f9769de"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soRemDetachDirEntry </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nInodeDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>eName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>op</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Remove / detach a generic entry from a directory. </p>
<p>The entry whose name is <code>eName</code> is removed / detached from the directory associated with the inode whose number is <code>nInodeDir</code>. Thus, the inode must be in use and belong to the directory type.</p>
<p>Removal of a directory entry means exchanging the first and the last characters of the field <em>name</em>. Detachment of a directory entry means filling all the characters of the field <em>name</em> with the <code>NULL</code> character.</p>
<p>The <code>eName</code> must be a <em>base name</em> and not a <em>path</em>, that is, it can not contain the character '/'. Besides there should exist an entry in the directory whose <em>name</em> field is <code>eName</code>.</p>
<p>Whenever the operation is removal and the type of the inode associated to the entry to be removed is of directory type, the operation can only be carried out if the directory is empty.</p>
<p>The <em>refcount</em> field of the inode associated to the entry to be removed / detached and, when required, of the inode associated to the directory are updated.</p>
<p>The file described by the inode associated to the entry to be removed / detached is only deleted from the file system if the <em>refcount</em> field becomes zero (there are no more hard links associated to it). In this case, the data clusters that store the file contents and the inode itself must be freed.</p>
<p>The process that calls the operation must have write (w) and execution (x) permissions on the directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInodeDir</td><td>number of the inode associated to the directory </td></tr>
    <tr><td class="paramname">eName</td><td>pointer to the string holding the name of the directory entry to be removed / detached </td></tr>
    <tr><td class="paramname">op</td><td>type of operation (REM / DETACH)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the <em>inode number</em> is out of range or the pointer to the string is <code>NULL</code> or the name string does not describe a file name or no operation of the defined class is described </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the name string exceeds the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if the inode type whose number is <code>nInodeDir</code> is not a directory </dd>
<dd>
-<code>ENOENT</code>, if no entry with <code>eName</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on the directory </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the directory </dd>
<dd>
-<code>ENOTEMPTY</code>, if the entry with <code>eName</code> describes a non-empty directory </dd>
<dd>
-<code>EDIRINVAL</code>, if the directory is inconsistent </dd>
<dd>
-<code>EDEINVAL</code>, if the directory entry is inconsistent </dd>
<dd>
-<code>EIUININVAL</code>, if the inode in use is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>EDCINVAL</code>, if the data cluster header is inconsistent </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="ab2b1d32979a19de7d7858adc48963c39"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soRenameDirEntry </td>
          <td>(</td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>nInodeDir</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>oldName</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newName</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Rename an entry of a directory. </p>
<p>The directory entry whose name is <code>oldName</code> has its <em>name</em> field changed to <code>newName</code>. Thus, the inode associated to the directory must be in use and belong to the directory type.</p>
<p>Both the <code>oldName</code> and the <code>newName</code> must be <em>base names</em> and not <em>paths</em>, that is, they can not contain the character '/'. Besides an entry whose <em>name</em> field is <code>oldName</code> should exist in the directory and there should not be any entry in the directory whose <em>name</em> field is <code>newName</code>.</p>
<p>The process that calls the operation must have write (w) and execution (x) permissions on the directory.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">nInodeDir</td><td>number of the inode associated to the directory </td></tr>
    <tr><td class="paramname">oldName</td><td>pointer to the string holding the name of the direntry to be renamed </td></tr>
    <tr><td class="paramname">newName</td><td>pointer to the string holding the new name</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the <em>inode number</em> is out of range or either one of the pointers to the strings are <code>NULL</code> or the name strings do not describe file names </dd>
<dd>
-<code>ENAMETOOLONG</code>, if one of the name strings exceeds the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if the inode type is not a directory </dd>
<dd>
-<code>ENOENT</code>, if no entry with <code>oldName</code> is found </dd>
<dd>
-<code>EEXIST</code>, if an entry with the <code>newName</code> already exists </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on the directory </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the directory </dd>
<dd>
-<code>EDIRINVAL</code>, if the directory is inconsistent </dd>
<dd>
-<code>EDEINVAL</code>, if the directory entry is inconsistent </dd>
<dd>
-<code>EIUININVAL</code>, if the inode in use is inconsistent </dd>
<dd>
-<code>ELDCININVAL</code>, if the list of data cluster references belonging to an inode is inconsistent </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails reading or writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_f68df188f887538d2ebe3f1167d956ea.html">sofs15</a></li><li class="navelem"><a class="el" href="sofs__ifuncs__4_8h.html">sofs_ifuncs_4.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
