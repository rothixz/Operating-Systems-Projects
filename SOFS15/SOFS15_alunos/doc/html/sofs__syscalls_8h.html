<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.6"/>
<title>SOFS15: sofs_syscalls.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">SOFS15
   &#160;<span id="projectnumber">1.0</span>
   </div>
   <div id="projectbrief">FUSE based file system</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.6 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('sofs__syscalls_8h.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">sofs_syscalls.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Set of operations to manage system calls.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;unistd.h&gt;</code><br/>
<code>#include &lt;fcntl.h&gt;</code><br/>
<code>#include &lt;stdint.h&gt;</code><br/>
<code>#include &lt;sys/types.h&gt;</code><br/>
<code>#include &lt;sys/statvfs.h&gt;</code><br/>
<code>#include &lt;sys/stat.h&gt;</code><br/>
<code>#include &lt;time.h&gt;</code><br/>
<code>#include &lt;utime.h&gt;</code><br/>
<code>#include &lt;libgen.h&gt;</code><br/>
</div>
<p><a href="sofs__syscalls_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a1805c069be94614ff9fd88391e8da060"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a1805c069be94614ff9fd88391e8da060">soMountSOFS</a> (const char *devname)</td></tr>
<tr class="memdesc:a1805c069be94614ff9fd88391e8da060"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mount the SOFS12 file system.  <a href="#a1805c069be94614ff9fd88391e8da060">More...</a><br/></td></tr>
<tr class="separator:a1805c069be94614ff9fd88391e8da060"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a18f674558eab695015444fa77af39e6d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a18f674558eab695015444fa77af39e6d">soUnmountSOFS</a> (void)</td></tr>
<tr class="memdesc:a18f674558eab695015444fa77af39e6d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unmount the SOFS12 file system.  <a href="#a18f674558eab695015444fa77af39e6d">More...</a><br/></td></tr>
<tr class="separator:a18f674558eab695015444fa77af39e6d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac94558f3fd27529d5a81ed479025f18d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#ac94558f3fd27529d5a81ed479025f18d">soStatFS</a> (const char *ePath, struct statvfs *st)</td></tr>
<tr class="memdesc:ac94558f3fd27529d5a81ed479025f18d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get file system statistics.  <a href="#ac94558f3fd27529d5a81ed479025f18d">More...</a><br/></td></tr>
<tr class="separator:ac94558f3fd27529d5a81ed479025f18d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ce618672344fe2b4acbb61b1a0bc281"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a6ce618672344fe2b4acbb61b1a0bc281">soStat</a> (const char *ePath, struct stat *st)</td></tr>
<tr class="memdesc:a6ce618672344fe2b4acbb61b1a0bc281"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get file status.  <a href="#a6ce618672344fe2b4acbb61b1a0bc281">More...</a><br/></td></tr>
<tr class="separator:a6ce618672344fe2b4acbb61b1a0bc281"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af81bf1bb69be42a3b0127b001368da50"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#af81bf1bb69be42a3b0127b001368da50">soAccess</a> (const char *ePath, int opRequested)</td></tr>
<tr class="memdesc:af81bf1bb69be42a3b0127b001368da50"><td class="mdescLeft">&#160;</td><td class="mdescRight">Check real user's permissions for a file.  <a href="#af81bf1bb69be42a3b0127b001368da50">More...</a><br/></td></tr>
<tr class="separator:af81bf1bb69be42a3b0127b001368da50"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a04ec0ab1233ee30ab740387f7dc50569"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a04ec0ab1233ee30ab740387f7dc50569">soChmod</a> (const char *ePath, mode_t mode)</td></tr>
<tr class="memdesc:a04ec0ab1233ee30ab740387f7dc50569"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change permissions of a file.  <a href="#a04ec0ab1233ee30ab740387f7dc50569">More...</a><br/></td></tr>
<tr class="separator:a04ec0ab1233ee30ab740387f7dc50569"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a15ab14e6f57832e96fa6560795b23deb"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a15ab14e6f57832e96fa6560795b23deb">soChown</a> (const char *ePath, uid_t owner, gid_t group)</td></tr>
<tr class="memdesc:a15ab14e6f57832e96fa6560795b23deb"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the ownership of a file.  <a href="#a15ab14e6f57832e96fa6560795b23deb">More...</a><br/></td></tr>
<tr class="separator:a15ab14e6f57832e96fa6560795b23deb"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8ffec27f63bab8cbdcaab645ef3b5e49"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a8ffec27f63bab8cbdcaab645ef3b5e49">soUtime</a> (const char *ePath, const struct utimbuf *times)</td></tr>
<tr class="memdesc:a8ffec27f63bab8cbdcaab645ef3b5e49"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the last access and modification times of a file.  <a href="#a8ffec27f63bab8cbdcaab645ef3b5e49">More...</a><br/></td></tr>
<tr class="separator:a8ffec27f63bab8cbdcaab645ef3b5e49"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac35d8f8e3fc366bde219230e7686d27"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#aac35d8f8e3fc366bde219230e7686d27">soUtimens</a> (const char *ePath, const struct timespec tv[2])</td></tr>
<tr class="memdesc:aac35d8f8e3fc366bde219230e7686d27"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the last access and modification times of a file with nanosecond resolution.  <a href="#aac35d8f8e3fc366bde219230e7686d27">More...</a><br/></td></tr>
<tr class="separator:aac35d8f8e3fc366bde219230e7686d27"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3548e2dc6fc347ee7c5b42f56131407d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a3548e2dc6fc347ee7c5b42f56131407d">soOpen</a> (const char *ePath, int flags)</td></tr>
<tr class="memdesc:a3548e2dc6fc347ee7c5b42f56131407d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a regular file.  <a href="#a3548e2dc6fc347ee7c5b42f56131407d">More...</a><br/></td></tr>
<tr class="separator:a3548e2dc6fc347ee7c5b42f56131407d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a0d4b28380c3878ac4133afd5a47845"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a6a0d4b28380c3878ac4133afd5a47845">soClose</a> (const char *ePath)</td></tr>
<tr class="memdesc:a6a0d4b28380c3878ac4133afd5a47845"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a regular file.  <a href="#a6a0d4b28380c3878ac4133afd5a47845">More...</a><br/></td></tr>
<tr class="separator:a6a0d4b28380c3878ac4133afd5a47845"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8802ddd31f3e315d20778321251c3ce1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a8802ddd31f3e315d20778321251c3ce1">soFsync</a> (const char *ePath)</td></tr>
<tr class="memdesc:a8802ddd31f3e315d20778321251c3ce1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Synchronize a file's in-core state with storage device.  <a href="#a8802ddd31f3e315d20778321251c3ce1">More...</a><br/></td></tr>
<tr class="separator:a8802ddd31f3e315d20778321251c3ce1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e4a5f041fbe2a91b5d93623e88dbe2f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a2e4a5f041fbe2a91b5d93623e88dbe2f">soOpendir</a> (const char *ePath)</td></tr>
<tr class="memdesc:a2e4a5f041fbe2a91b5d93623e88dbe2f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Open a directory for reading.  <a href="#a2e4a5f041fbe2a91b5d93623e88dbe2f">More...</a><br/></td></tr>
<tr class="separator:a2e4a5f041fbe2a91b5d93623e88dbe2f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aaa5da9eaa7db8ac7e5246884b973608e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#aaa5da9eaa7db8ac7e5246884b973608e">soClosedir</a> (const char *ePath)</td></tr>
<tr class="memdesc:aaa5da9eaa7db8ac7e5246884b973608e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Close a directory.  <a href="#aaa5da9eaa7db8ac7e5246884b973608e">More...</a><br/></td></tr>
<tr class="separator:aaa5da9eaa7db8ac7e5246884b973608e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a937c048ec74c55af02c40c349f85af5d"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a937c048ec74c55af02c40c349f85af5d">soLink</a> (const char *oldPath, const char *newPath)</td></tr>
<tr class="memdesc:a937c048ec74c55af02c40c349f85af5d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a new name for a file.  <a href="#a937c048ec74c55af02c40c349f85af5d">More...</a><br/></td></tr>
<tr class="separator:a937c048ec74c55af02c40c349f85af5d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a276629202749786d8c570ce67ed6f9b9"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a276629202749786d8c570ce67ed6f9b9">soUnlink</a> (const char *ePath)</td></tr>
<tr class="memdesc:a276629202749786d8c570ce67ed6f9b9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete the name of a file from a directory and possibly the file it refers to from the file system.  <a href="#a276629202749786d8c570ce67ed6f9b9">More...</a><br/></td></tr>
<tr class="separator:a276629202749786d8c570ce67ed6f9b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abea00e56afa699dc0a3c118304e0e15c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#abea00e56afa699dc0a3c118304e0e15c">soRename</a> (const char *oldPath, const char *newPath)</td></tr>
<tr class="memdesc:abea00e56afa699dc0a3c118304e0e15c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Change the name or the location of a file in the directory hierarchy of the file system.  <a href="#abea00e56afa699dc0a3c118304e0e15c">More...</a><br/></td></tr>
<tr class="separator:abea00e56afa699dc0a3c118304e0e15c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abc771321231500d8e3b51b25e1b9a919"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#abc771321231500d8e3b51b25e1b9a919">soMknod</a> (const char *ePath, mode_t mode)</td></tr>
<tr class="memdesc:abc771321231500d8e3b51b25e1b9a919"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a regular file with size 0.  <a href="#abc771321231500d8e3b51b25e1b9a919">More...</a><br/></td></tr>
<tr class="separator:abc771321231500d8e3b51b25e1b9a919"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8accfb94c629e0f1a22531188380def7"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a8accfb94c629e0f1a22531188380def7">soRead</a> (const char *ePath, void *buff, uint32_t count, int32_t pos)</td></tr>
<tr class="memdesc:a8accfb94c629e0f1a22531188380def7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read data from an open regular file.  <a href="#a8accfb94c629e0f1a22531188380def7">More...</a><br/></td></tr>
<tr class="separator:a8accfb94c629e0f1a22531188380def7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a3cd31d386946336f121be6a4c0c696b8"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a3cd31d386946336f121be6a4c0c696b8">soWrite</a> (const char *ePath, void *buff, uint32_t count, int32_t pos)</td></tr>
<tr class="memdesc:a3cd31d386946336f121be6a4c0c696b8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write data into an open regular file.  <a href="#a3cd31d386946336f121be6a4c0c696b8">More...</a><br/></td></tr>
<tr class="separator:a3cd31d386946336f121be6a4c0c696b8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac73c92cbdac16bd6b953313163f62a95"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#ac73c92cbdac16bd6b953313163f62a95">soTruncate</a> (const char *ePath, off_t length)</td></tr>
<tr class="memdesc:ac73c92cbdac16bd6b953313163f62a95"><td class="mdescLeft">&#160;</td><td class="mdescRight">Truncate a regular file to a specified length.  <a href="#ac73c92cbdac16bd6b953313163f62a95">More...</a><br/></td></tr>
<tr class="separator:ac73c92cbdac16bd6b953313163f62a95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac61d622e46490a7e0be7a870fd488795"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#ac61d622e46490a7e0be7a870fd488795">soMkdir</a> (const char *ePath, mode_t mode)</td></tr>
<tr class="memdesc:ac61d622e46490a7e0be7a870fd488795"><td class="mdescLeft">&#160;</td><td class="mdescRight">Create a directory.  <a href="#ac61d622e46490a7e0be7a870fd488795">More...</a><br/></td></tr>
<tr class="separator:ac61d622e46490a7e0be7a870fd488795"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2df6b0fc3daf9498a7f6135b50c399d2"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a2df6b0fc3daf9498a7f6135b50c399d2">soRmdir</a> (const char *ePath)</td></tr>
<tr class="memdesc:a2df6b0fc3daf9498a7f6135b50c399d2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Delete a directory.  <a href="#a2df6b0fc3daf9498a7f6135b50c399d2">More...</a><br/></td></tr>
<tr class="separator:a2df6b0fc3daf9498a7f6135b50c399d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8156e1924826324c96626e9ed7d19b72"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a8156e1924826324c96626e9ed7d19b72">soReaddir</a> (const char *ePath, void *buff, int32_t pos)</td></tr>
<tr class="memdesc:a8156e1924826324c96626e9ed7d19b72"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read a directory entry from a directory.  <a href="#a8156e1924826324c96626e9ed7d19b72">More...</a><br/></td></tr>
<tr class="separator:a8156e1924826324c96626e9ed7d19b72"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac9e0b8ae91322c6bee81df15731bc524"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#ac9e0b8ae91322c6bee81df15731bc524">soSymlink</a> (const char *effPath, const char *ePath)</td></tr>
<tr class="memdesc:ac9e0b8ae91322c6bee81df15731bc524"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a new name for a regular file or a directory.  <a href="#ac9e0b8ae91322c6bee81df15731bc524">More...</a><br/></td></tr>
<tr class="separator:ac9e0b8ae91322c6bee81df15731bc524"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7cae47fa1e796132be0376b7f0091280"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="sofs__syscalls_8h.html#a7cae47fa1e796132be0376b7f0091280">soReadlink</a> (const char *ePath, const char *buff, int32_t size)</td></tr>
<tr class="memdesc:a7cae47fa1e796132be0376b7f0091280"><td class="mdescLeft">&#160;</td><td class="mdescRight">Read the value of a symbolic link.  <a href="#a7cae47fa1e796132be0376b7f0091280">More...</a><br/></td></tr>
<tr class="separator:a7cae47fa1e796132be0376b7f0091280"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Set of operations to manage system calls. </p>
<p>(interface file)</p>
<p>The aim is to provide an unique description of the functions that operate at this level.</p>
<p>The operations are: </p>
<ul>
<li>mount the SOFS12 file system </li>
<li>unmount the SOFS12 file system </li>
<li>get file system statistics </li>
<li>get file status </li>
<li>check real user's permissions for a file </li>
<li>change permissions of a file </li>
<li>change the ownership of a file </li>
<li>change the last access and modification times of a file </li>
<li>change the last access and modification times of a file with nanosecond resolution </li>
<li>make a new name for a file </li>
<li>delete the name of a file from a directory and possibly the file it refers to from the file system </li>
<li>change the name or the location of a file in the directory hierarchy of the file system </li>
<li>create a regular file with size 0 </li>
<li>open a regular file </li>
<li>close a regular file </li>
<li>read data from an open regular file </li>
<li>write data into an open regular file </li>
<li>truncate a regular file to a specified length </li>
<li>synchronize a file's in-core state with storage device </li>
<li>create a directory </li>
<li>delete a directory </li>
<li>open a directory for reading </li>
<li>read a directory entry from a directory </li>
<li>close a directory </li>
<li>make a new name for a regular file or a directory </li>
<li>read the value of a symbolic link.</li>
</ul>
<dl class="section author"><dt>Author</dt><dd>Artur Carneiro Pereira September 2007 </dd>
<dd>
Miguel Oliveira e Silva September 2009 </dd>
<dd>
Ant√≥nio Rui Borges - October 2010 / October 2012 </dd></dl>
</div><h2 class="groupheader">Function Documentation</h2>
<a class="anchor" id="af81bf1bb69be42a3b0127b001368da50"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soAccess </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>opRequested</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Check real user's permissions for a file. </p>
<p>It tries to emulate <em>access</em> system call.</p>
<p>It checks whether the calling process can access the file specified by the path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ePath</td><td>path to the file </td></tr>
    <tr><td class="paramname">opRequested</td><td>operation to be performed: F_OK (check if file exists) a bitwise combination of R_OK, W_OK, and X_OK</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string is a <code>NULL</code> string or the path does not describe an absolute path or no operation of the defined class is described </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one, or the operation is denied </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a04ec0ab1233ee30ab740387f7dc50569"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soChmod </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change permissions of a file. </p>
<p>It tries to emulate <em>chmod</em> system call.</p>
<p>It changes the permissions of a file specified by the path.</p>
<dl class="section remark"><dt>Remarks</dt><dd>If the file is a symbolic link, its contents shall always be used to reach the destination file, so the permissions of a symbolic link can never be changed (they are set to rwx for <em>user</em>, <em>group</em> and <em>other</em> when the link is created and remain unchanged thereafter).</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ePath</td><td>path to the file </td></tr>
    <tr><td class="paramname">mode</td><td>permissions to be set: a bitwise combination of S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string is a <code>NULL</code> string or the path does not describe an absolute path or no mode of the defined class is described </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation is neither the file's owner, nor is <em>root</em> </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a15ab14e6f57832e96fa6560795b23deb"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soChown </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uid_t&#160;</td>
          <td class="paramname"><em>owner</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">gid_t&#160;</td>
          <td class="paramname"><em>group</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the ownership of a file. </p>
<p>It tries to emulate <em>chown</em> system call.</p>
<p>It changes the ownership of a file specified by the path.</p>
<p>Only <em>root</em> may change the owner of a file. The file's owner may change the group if the specified group is one of the owner's supplementary groups.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ePath</td><td>path to the file </td></tr>
    <tr><td class="paramname">owner</td><td>file user id (-1, if user is not to be changed) </td></tr>
    <tr><td class="paramname">group</td><td>file group id (-1, if group is not to be changed)</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string is a <code>NULL</code> string or the path does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation is neither the file's owner, nor is <em>root</em>, nor the specified group is one of the owner's supplementary groups </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a6a0d4b28380c3878ac4133afd5a47845"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soClose </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a regular file. </p>
<p>It tries to emulate <em>close</em> system call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ePath</td><td>path to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string is a <code>NULL</code> string or the path does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EISDIR</code>, if <code>ePath</code> represents a directory </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="aaa5da9eaa7db8ac7e5246884b973608e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soClosedir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Close a directory. </p>
<p>It tries to emulate <em>closedir</em> system call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ePath</td><td>path to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string is a <code>NULL</code> string or the path does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code> is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a8802ddd31f3e315d20778321251c3ce1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soFsync </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Synchronize a file's in-core state with storage device. </p>
<p>It tries to emulate <em>fsync</em> system call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ePath</td><td>path to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string is a <code>NULL</code> string or the path does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a937c048ec74c55af02c40c349f85af5d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soLink </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>oldPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a new name for a file. </p>
<p>It tries to emulate <em>link</em> system call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldPath</td><td>path to an existing file </td></tr>
    <tr><td class="paramname">newPath</td><td>new path to the same file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to either of the strings is <code>NULL</code> or any of the path strings is a <code>NULL</code> string or the path strings do not describe absolute paths </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the paths names or any of their components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of both paths, but the last one, are not directories </dd>
<dd>
-<code>ELOOP</code>, if either path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>oldPath</code>, or to any of the components of <code>newPath</code>, but the last one, is found </dd>
<dd>
-<code>EEXIST</code>, if a file described by <code>newPath</code> already exists </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of both paths, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the directory where <code>newPath</code> entry is to be added, or <code>oldPath</code> represents a directory </dd>
<dd>
-<code>ENOSPC</code>, if there are no free data clusters </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="ac61d622e46490a7e0be7a870fd488795"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soMkdir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a directory. </p>
<p>It tries to emulate <em>mkdir</em> system call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ePath</td><td>path to the file </td></tr>
    <tr><td class="paramname">mode</td><td>type and permissions to be set: a bitwise combination of S_ISVTX, S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or or the path string is a <code>NULL</code> string or the path does not describe an absolute path or no mode of the defined class is described </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code> is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code>, but the last one, is found </dd>
<dd>
-<code>EEXIST</code>, if a file described by <code>ePath</code> already exists or the last component is a symbolic link </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the directory that will hold <code>ePath</code> </dd>
<dd>
-<code>ENOSPC</code>, if there are no free data clusters </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="abc771321231500d8e3b51b25e1b9a919"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soMknod </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">mode_t&#160;</td>
          <td class="paramname"><em>mode</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Create a regular file with size 0. </p>
<p>It tries to emulate <em>mknod</em> system call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ePath</td><td>path to the file </td></tr>
    <tr><td class="paramname">mode</td><td>type and permissions to be set: a bitwise combination of S_IFREG, S_IRUSR, S_IWUSR, S_IXUSR, S_IRGRP, S_IWGRP, S_IXGRP, S_IROTH, S_IWOTH, S_IXOTH</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or or the path string is a <code>NULL</code> string or the path does not describe an absolute path or no mode of the defined class is described </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code>, but the last one, is found </dd>
<dd>
-<code>EEXIST</code>, if a file described by <code>ePath</code> already exists or the last component is a symbolic link </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the directory that will hold <code>ePath</code> </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a1805c069be94614ff9fd88391e8da060"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soMountSOFS </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>devname</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Mount the SOFS12 file system. </p>
<p>A buffered communication channel is established with the storage device. The superblock is read and it is checked if the file system was properly unmounted the last time it was mounted. If not, a consistency check is performed (presently, the check is superficial, a more thorough one is required).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">devname</td><td>absolute path to the Linux file that simulates the storage device</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if if the pointer to <em>device path</em> is <code>NULL</code> or is a <code>NULL</code> string or the path does not describe an absolute path or the magic number is not the one characteristic of SOFS12 </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the absolute path exceeds the maximum allowed length </dd>
<dd>
-<code>EBUSY</code>, if the storage area is already in use or the device is already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a3548e2dc6fc347ee7c5b42f56131407d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soOpen </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a regular file. </p>
<p>It tries to emulate <em>open</em> system call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ePath</td><td>path to the file </td></tr>
    <tr><td class="paramname">flags</td><td>access modes to be used: O_RDONLY, O_WRONLY, O_RDWR</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string is a <code>NULL</code> string or the path does not describe an absolute path or no access mode of the defined class is described </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EISDIR</code>, if <code>ePath</code> represents a directory </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not the proper permission (read / write) on the file described by <code>ePath</code> </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a2e4a5f041fbe2a91b5d93623e88dbe2f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soOpendir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Open a directory for reading. </p>
<p>It tries to emulate <em>opendir</em> system call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ePath</td><td>path to the file</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string is a <code>NULL</code> string or the path does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code> is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not read permission on the directory described by <code>ePath</code> </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a8accfb94c629e0f1a22531188380def7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soRead </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read data from an open regular file. </p>
<p>It tries to emulate <em>read</em> system call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ePath</td><td>path to the file </td></tr>
    <tr><td class="paramname">buff</td><td>pointer to the buffer where data to be read is to be stored </td></tr>
    <tr><td class="paramname">count</td><td>number of bytes to be read </td></tr>
    <tr><td class="paramname">pos</td><td>starting [byte] position in the file data continuum where data is to be read from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>number of bytes effectively read</em>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or or the path string is a <code>NULL</code> string or the path does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>EISDIR</code>, if <code>ePath</code> describes a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EFBIG</code>, if the starting [byte] position in the file data continuum assumes a value passing its maximum size </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not read permission on the file described by <code>ePath</code> </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a8156e1924826324c96626e9ed7d19b72"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soReaddir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read a directory entry from a directory. </p>
<p>It tries to emulate <em>getdents</em> system call, but it reads a single directory entry in use at a time.</p>
<p>Only the field <em>name</em> is read.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The returned value is the number of bytes read from the directory in order to get the next in use directory entry. So, skipped free directory entries must be accounted for. The point is that the system (through FUSE) uses the returned value to update file position.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ePath</td><td>path to the file </td></tr>
    <tr><td class="paramname">buff</td><td>pointer to the buffer where data to be read is to be stored </td></tr>
    <tr><td class="paramname">pos</td><td>starting [byte] position in the file data continuum where data is to be read from</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>number of bytes effectively read to get a directory entry in use (0, if the end is reached)</em>, on success </dd>
<dd>
-<code>EINVAL</code>, if either of the pointers are <code>NULL</code> or or the path string is a <code>NULL</code> string or the path does not describe an absolute path or <em>pos</em> value is not a multiple of the size of a <em>directory entry</em> </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ERELPATH</code>, if the path is relative </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code> is not a directory </dd>
<dd>
-<code>EFBIG</code>, if the <em>pos</em> value is beyond the maximum file size </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not read permission on the directory described by <code>ePath</code> </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a7cae47fa1e796132be0376b7f0091280"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soReadlink </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Read the value of a symbolic link. </p>
<p>It tries to emulate <em>readlink</em> system call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ePath</td><td>path to the symbolic link </td></tr>
    <tr><td class="paramname">buff</td><td>pointer to the buffer where data to be read is to be stored </td></tr>
    <tr><td class="paramname">size</td><td>buffer size in bytes</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>number of bytes effectively read</em>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or or the path string is a <code>NULL</code> string or the path does not describe an absolute path or <code>ePath</code> does not represent a symbolic link </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length or the buffer size is not large enough </dd>
<dd>
-<code>ERELPATH</code>, if the path is relative </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not read permission on the symbolic link described by <code>ePath</code> </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="abea00e56afa699dc0a3c118304e0e15c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soRename </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>oldPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>newPath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the name or the location of a file in the directory hierarchy of the file system. </p>
<p>It tries to emulate <em>rename</em> system call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">oldPath</td><td>path to an existing file </td></tr>
    <tr><td class="paramname">newPath</td><td>new path to the same file in replacement of the old one</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to either of the strings is <code>NULL</code> or any of the path strings is a <code>NULL</code> string or any of the paths do not describe absolute paths or <code>oldPath</code> describes a directory and is a substring of <code>newPath</code> (attempt to make a directory a subdirectory of itself) </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the paths names or any of their components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of both paths, but the last one, are not directories, or <code>oldPath</code> describes a directory and <code>newPath</code>, although it exists, does not </dd>
<dd>
-<code>EISDIR</code>, if <code>newPath</code> describes a directory and <code>oldPath</code> does not </dd>
<dd>
-<code>ELOOP</code>, if either path resolves to more than one symbolic link </dd>
<dd>
-<code>EMLINK</code>, if <code>oldPath</code> is a directory and the directory containing <code>newPath</code> has already the maximum number of links, or <code>oldPath</code> has already the maximum number of links and is not contained in the same directory that will contain <code>newPath</code> </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>oldPath</code>, or to any of the components of <code>newPath</code>, but the last one, is found </dd>
<dd>
-<code>ENOTEMPTY</code>, if both <code>oldPath</code> and <code>newPath</code> describe directories and <code>newPath</code> is not empty </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of both paths, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the directories where <code>newPath</code> entry is to be added and <code>oldPath</code> is to be detached </dd>
<dd>
-<code>ENOSPC</code>, if there are no free data clusters </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a2df6b0fc3daf9498a7f6135b50c399d2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soRmdir </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete a directory. </p>
<p>It tries to emulate <em>rmdir</em> system call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ePath</td><td>path to the directory to be deleted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string is a <code>NULL</code> string or the path does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of the path is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>ENOTEMPTY</code>, if <code>ePath</code> describes a non-empty directory </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of the path, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the directory where <code>ePath</code> entry is to be removed </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a6ce618672344fe2b4acbb61b1a0bc281"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soStat </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct stat *&#160;</td>
          <td class="paramname"><em>st</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get file status. </p>
<p>It tries to emulate <em>stat</em> system call.</p>
<p>Information about a specific file is returned. It checks whether the calling process can access the file specified by the path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ePath</td><td>path to the file </td></tr>
    <tr><td class="paramname">st</td><td>pointer to a stat structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if any of the pointers are <code>NULL</code> or the path string is a <code>NULL</code> string or the path does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="ac94558f3fd27529d5a81ed479025f18d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soStatFS </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct statvfs *&#160;</td>
          <td class="paramname"><em>st</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get file system statistics. </p>
<p>It tries to emulate <em>statvfs</em> system call.</p>
<p>Information about a mounted file system is returned. It checks whether the calling process can access the file specified by the path.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ePath</td><td>path to any file within the mounted file system </td></tr>
    <tr><td class="paramname">st</td><td>pointer to a statvfs structure</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if any of the pointers are <code>NULL</code> or the path string is a <code>NULL</code> string or the path does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="ac9e0b8ae91322c6bee81df15731bc524"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soSymlink </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>effPath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ePath</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a new name for a regular file or a directory. </p>
<p>It tries to emulate <em>symlink</em> system call.</p>
<dl class="section remark"><dt>Remarks</dt><dd>The permissions set for the symbolic link should have read (r), write (w) and execution (x) permissions for both <em>user</em>, <em>group</em> and <em>other</em>.</dd></dl>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">effPath</td><td>path to be stored in the symbolic link file </td></tr>
    <tr><td class="paramname">ePath</td><td>path to the symbolic link</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to either of the strings is <code>NULL</code> or or any of the path strings is a <code>NULL</code> string or the second string does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the either path names or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ERELPATH</code>, if the second path is relative </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of the second path, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the second path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code>, but the last one, is found </dd>
<dd>
-<code>EEXIST</code>, if a file described by <code>ePath</code> already exists </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of the second path, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the directory where <code>ePath</code> entry is to be added </dd>
<dd>
-<code>ENOSPC</code>, if there are no free data clusters </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="ac73c92cbdac16bd6b953313163f62a95"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soTruncate </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">off_t&#160;</td>
          <td class="paramname"><em>length</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Truncate a regular file to a specified length. </p>
<p>It tries to emulate <em>truncate</em> system call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ePath</td><td>path to the file </td></tr>
    <tr><td class="paramname">length</td><td>new size for the regular size</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or or the path string is a <code>NULL</code> string or the path does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>EISDIR</code>, if <code>ePath</code> describes a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EFBIG</code>, if the file may grow passing its maximum size </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the file described by <code>ePath</code> </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a276629202749786d8c570ce67ed6f9b9"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soUnlink </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ePath</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Delete the name of a file from a directory and possibly the file it refers to from the file system. </p>
<p>It tries to emulate <em>unlink</em> system call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ePath</td><td>path to the file to be deleted</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or or the path string is a <code>NULL</code> string or the path does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of the path, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of the path, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the directory where <code>ePath</code> entry is to be removed </dd>
<dd>
-<code>EISDIR</code>, if <code>ePath</code> represents a directory </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a18f674558eab695015444fa77af39e6d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soUnmountSOFS </td>
          <td>(</td>
          <td class="paramtype">void&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unmount the SOFS12 file system. </p>
<p>The buffered communication channel previously established with the storage device is closed. This means, namely, that the contents of the storage area is flushed into the storage device to keep data update. Before that, however, the mount flag of the superblock is set to <em>properly unmounted</em>.</p>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a8ffec27f63bab8cbdcaab645ef3b5e49"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soUtime </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct utimbuf *&#160;</td>
          <td class="paramname"><em>times</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the last access and modification times of a file. </p>
<p>It tries to emulate <em>utime</em> system call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ePath</td><td>path to the file </td></tr>
    <tr><td class="paramname">times</td><td>pointer to a structure where the last access and modification times are passed, if <code>NULL</code>, the last access and modification times are set to the current time</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string is a <code>NULL</code> string or the path does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation is neither the file's owner, nor is <em>root</em>, or has not write permission </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="aac35d8f8e3fc366bde219230e7686d27"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soUtimens </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct timespec&#160;</td>
          <td class="paramname"><em>tv</em>[2]&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Change the last access and modification times of a file with nanosecond resolution. </p>
<p>It tries to emulate <em>utimensat</em> system call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ePath</td><td>path to the file </td></tr>
    <tr><td class="paramname">tv</td><td>structure array where the last access, element of index 0, and modification, element of index 1, times are passed, if <code>NULL</code>, the last access and modification times are set to the current time if the <code>tv_nsec</code> field of one of the <code>timespec</code> structures has the special value <code>UTIME_NOW</code>, then the corresponding file timestamp is set to the current time if the <code>tv_nsec</code> field of one of the <code>timespec</code> structures has the special value <code>UTIME_OMIT</code>, then the corresponding file timestamp is left unchanged</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><code>0 (zero)</code>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or the path string is a <code>NULL</code> string or the path does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation is neither the file's owner, nor is <em>root</em>, or has not write permission </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
<a class="anchor" id="a3cd31d386946336f121be6a4c0c696b8"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int soWrite </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>ePath</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buff</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname"><em>count</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int32_t&#160;</td>
          <td class="paramname"><em>pos</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write data into an open regular file. </p>
<p>It tries to emulate <em>write</em> system call.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">ePath</td><td>path to the file </td></tr>
    <tr><td class="paramname">buff</td><td>pointer to the buffer where data to be written is stored </td></tr>
    <tr><td class="paramname">count</td><td>number of bytes to be written </td></tr>
    <tr><td class="paramname">pos</td><td>starting [byte] position in the file data continuum where data is to be written into</td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd><em>number of bytes effectively written</em>, on success </dd>
<dd>
-<code>EINVAL</code>, if the pointer to the string is <code>NULL</code> or or the path string is a <code>NULL</code> string or the path does not describe an absolute path </dd>
<dd>
-<code>ENAMETOOLONG</code>, if the path name or any of its components exceed the maximum allowed length </dd>
<dd>
-<code>ENOTDIR</code>, if any of the components of <code>ePath</code>, but the last one, is not a directory </dd>
<dd>
-<code>EISDIR</code>, if <code>ePath</code> describes a directory </dd>
<dd>
-<code>ELOOP</code>, if the path resolves to more than one symbolic link </dd>
<dd>
-<code>ENOENT</code>, if no entry with a name equal to any of the components of <code>ePath</code> is found </dd>
<dd>
-<code>EFBIG</code>, if the file may grow passing its maximum size </dd>
<dd>
-<code>EACCES</code>, if the process that calls the operation has not execution permission on any of the components of <code>ePath</code>, but the last one </dd>
<dd>
-<code>EPERM</code>, if the process that calls the operation has not write permission on the file described by <code>ePath</code> </dd>
<dd>
-<code>ENOSPC</code>, if there are no free data clusters </dd>
<dd>
-<code>ELIBBAD</code>, if some kind of inconsistency was detected at some internal storage lower level </dd>
<dd>
-<code>EBADF</code>, if the device is not already opened </dd>
<dd>
-<code>EIO</code>, if it fails on writing </dd>
<dd>
-<em>other specific error</em> issued by <em>lseek</em> system call </dd></dl>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_68267d1309a1af8e8297ef4c3efbcdba.html">src</a></li><li class="navelem"><a class="el" href="dir_e7c49c548e3316016327f07e16627134.html">syscalls15</a></li><li class="navelem"><a class="el" href="sofs__syscalls_8h.html">sofs_syscalls.h</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.6 </li>
  </ul>
</div>
</body>
</html>
